---
title: El integrado MCP2221/A
layout: post
assets: /assets/2023/09/integrado-mcp2221
image: /assets/2023/09/integrado-mcp2221/img/led_blink_brd.gif
featured: false
description: Descripción del integrado MCP2221/A con múltiples montajes y proyectos en Python.
tags:
  - Circuitos
  - Experimentos
  - Informática
  - Sensores
---

Cualquier aficionado a la electrónica encuentra muy motivador ver cómo su programa interactúa con el mundo real: ya sea encendiendo una lámpara, midiendo temperaturas o moviendo un motor. El **MCP2221** es un integrado fabricado por Microchip cuya función principal es hacer de interfaz **USB** a UART e **I2C**. Pero lo que realmente destaca en este chip es su sencillez de uso y sus 4 pines **GPIO**, capaces de manejar no sólo señales digitales, sino también **analógicas**.

Los pines GPIO son muy habituales en los **microcontroladores** (léase Arduino, ESP32, PIC, etc.). La desventaja, sin embargo, de trabajar con microcontroladores es que debemos **programarlos**. Algunos requieren un hardware específico, como los PIC. Otros, un IDE concreto como Arduino. Y, en caso de encontrarnos algún bug, en todos ellos el proceso de **depuración** es complicado.

El MCP2221/A nos da la posibilidad de utilizar pines GPIO directamente conectados al PC, como si fueran un **periférico** más.

En este artículo veremos qué puede hacer y cómo utilizarlo. Presentaremos las capacidades del integrado y sus limitaciones. Ilustraremos los usos más habituales con ayuda de **ejemplos en Python**. Proyectaremos una **interfaz universal USB** y terminaremos con algún proyecto más avanzado.


## El integrado MCP2221


El MCP2221 tiene sólo **14 patillas** y lo podéis encontrar en formato **DIP** *through hole*. Lo cual facilita montarlo directamente en una placa de prototipos. Lo mejor es que no requiere **ningún componente** adicional para ello.

{% include image.html file="basic_sch_brd.png" caption="El MCP2221/A no requiere más componentes externos. EyC." %}

Tampoco requiere **drivers** ya que utilizaremos una librería Python con la que manejaremos el dispositivo desde el espacio de usuario.

Contamos con 4 pines de propósito general (**GPIO**) que podemos emplear como:

- **Entradas o salidas digitales** con las que podemos leer el estado de interruptores o pulsadores, encender LEDs, accionar relés, mover un motor paso-a-paso, etc.
- **Entradas analógicas** (ADC) para leer potenciómetros, voltajes, intensidades, temperaturas, o cualquier otra magnitud que varíe de forma continua.
- **Salida analógica** (DAC) capaz de generar una tensión o forma de onda arbitraria.
- Detector de **interrupciones** para activar una señal cuando la entrada cambia de estado, aunque sea por un instante.
- Salida de **reloj** con varias frecuencias para sincronizar otros circuitos, generar ondas cuadradas, etc.

{% include image.html file="MCP2221_pinout.svg" caption="Pinout del MCP2221/A en formato DIP. EyC." %}

Aunque el chip se conecta directamente al puerto USB, os recomendamos usar un **aislador USB**. Este dispositivo crea una **barrera hardware** entre el controlador USB y el exterior. Tanto para la alimentación como para los datos. De esta forma no dañaréis el controlador si, por error, cortocircuitáis alguno de los cables.

El *datasheet* sugiere colocar condensadores de desacople en la alimentación y otro de *bypass* en el regulador interno de 3.3V. Si bien en las pruebas puede funcionar perfectamente sin ellos, estos componentes añadirán fiabilidad a nuestros montajes.

{% include image.html file="recommended_sch_brd.png" caption="Los dos condensadores son opcionales pero recomendados. EyC." %}

Una vez conectado, el PC lo identifica como un dispositivo con dos interfaces: una es de tipo **CDC** (*Communication Device Class*), para la UART, equivalente a un puerto serie. Y la otra es de tipo **HID** (*Human Interface Device*). Trabajaremos sólo con esta segunda.

La **limitación** más importante de este chip es su **velocidad de repuesta**, la cual viene marcada por la especificación USB para la interfaz HID. Esta dicta un *polling rate* máximo de 1000Hz. En la práctica esto se traduce en que sólo podemos enviar comandos al chip y recibir respuestas 500 veces por segundo.

Es decir, la frecuencia de muestreo del ADC, del DAC o de las entradas/salida lógicas estará **limitada** a un máximo de 500Hz. O, en otras palabras, no podemos generar o detectar eventos cuya separación temporal sea inferior a 2ms. Por otro lado, podemos despreocuparnos de detalles como dejar colgada la CPU en el bucle, el tiempo de adquisición de ADC o el tiempo de estabilización de la tensión de salida. Puesto que todos los comandos tienen este retardo.


## Módulo Python EasyMCP2221

Para operar con el MCP2221/A basta con enviar los mensajes apropiados a su **interfaz HID**. Contamos con librerías en varios lenguajes, algunas oficiales proporcionadas por Microchip, y otras *Open Source*.

[**Easy MCP2221**](https://easymcp2221.readthedocs.io/) es un **módulo Python** pensado para hacer pequeños **experimentos y prácticas**. De modo que cualquiera pueda usarlo fácilmente. Sin conocer detalles internos del integrado. Con los valores por defecto más habituales. Y con las funciones expuestas de forma **clara**, **bien documentada** y con **abundantes ejemplos**.

Tenéis toda la documentación en [readthedocs - Easy MCP2221](https://easymcp2221.readthedocs.io/). Ejemplos en [GitHub - EasyMCP2221](https://github.com/electronicayciencia/EasyMCP2221/tree/master).

Nada más ejecutar la librería debería reconocerlo y mostrarnos toda la información de configuración.

```python
>>> import EasyMCP2221
>>> EasyMCP2221.Device()
{
    "Chip settings": {
        "ADC reference value": "VDD",
        "Clock output duty cycle": 25,
        "Clock output frequency": "375kHz",
        "DAC output value": 21,
        "DAC reference value": "VDD",
        "Interrupt detection edge": "both",
        "Power management options": "disabled",
        "USB PID": "0x00DD",
        "USB VID": "0x04D8",
        "USB requested number of mA": 100
    },
    "Factory Serial Number": "01234567",
    "General Purpose IO settings": {
        "GP0": {
            "Default output value": 1,
            "Pin designated operation": "GPIO_IN"
        },
        "GP1": {
            "Default output value": 0,
            "Pin designated operation": "GPIO_IN"
        },
        "GP2": {
            "Default output value": 1,
            "Pin designated operation": "GPIO_IN"
        },
        "GP3": {
            "Default output value": 0,
            "Pin designated operation": "GPIO_IN"
        }
    },
    "USB Manufacturer": "Microchip Technology Inc.",
    "USB Product": "MCP2221 USB-I2C/UART Combo",
    "USB Serial Number": "0002596888"
}
```

Veamos algunos ejemplos sencillos para familiarizarnos con las funciones más comunes.


## Salidas digitales

Las **salidas lógicas** pueden conmutar entre nivel alto y nivel bajo. Sirven para fijar valores digitales. Cuando están en estado *bajo* su salida es cero. Y cuando están en estado *alto* es igual a la tensión de alimentación. En nuestro caso, 5V.

El MCP2221/A puede gestionar hasta 25mA por cada salida. Siempre que no excedamos los 90mA entre todas. Es suficiente para encender un LED. Pero si quisiéramos excitar un relé o alimentar un motor deberíamos amplificarla utilizando un transistor.

El ejemplo clásico para mostrar el uso de las salidas digitales hacer **parpadear un LED**.

Tan sólo conectaremos un led con una resistencia limitadora a cualquiera de las patillas de propósito general (GP). Ya que las cuatro pueden  actuar como entrada o salida lógica. Por ejemplo, **GP2**.

{% include image.html file="led_blink_sch.png" caption="Esquema y montaje utilizado en el ejemplo de salidas digitales. EyC." %}

En el código configuramos el pin que queramos como salida lógica. Luego alternamos su estado de salida en bucle.

```python
import EasyMCP2221

mcp = EasyMCP2221.Device()

mcp.set_pin_function(gp2 = "GPIO_OUT")

while True:
    mcp.GPIO_write(gp2 = True)
    sleep(0.5)
    mcp.GPIO_write(gp2 = False)
    sleep(0.5)
```

Resultado:

{% include image.html file="led_blink_brd.gif" caption="Hacemos parpadear el LED para demostrar que controlamos el estado de esa patilla. EyC." %}

Recuerda que sólo podemos enviar un comando al chip cada 2ms. Por lo que, al eliminar el *sleep*, obtendríamos una frecuencia máxima de **250Hz**.


## Entradas digitales

Las **entradas lógicas** permiten leer el estado de interruptores o pulsadores. Detectan un nivel alto cuando la tensión aplicada es superior a 1.2V aproximadamente. Y detectan como nivel bajo cualquier tensión inferior a este valor.

Un ejemplo muy sencillo sería hacer una puerta lógica combinando entradas y salidas. Hemos conectado dos interruptores a las patillas **GP1** y **GP2**, y un LED a la patilla **GP3**. En el bucle principal leemos las entradas, efectuamos la operación lógica, XOR en este caso, y
reflejamos el estado en la salida.

{% include image.html file="logicgate_sch_brd.png" caption="Esquema y montaje utilizado en el ejemplo de entrada digital. EyC." %}

El programa sería algo así:

```python
# GP1 and GP2 are inputs. GP3 will be an input.
mcp.set_pin_function(
    gp1 = "GPIO_IN",
    gp2 = "GPIO_IN",
    gp3 = "GPIO_OUT")

while True:
    (gp0, gp1, gp2, gp3) = mcp.GPIO_read()

    mcp.GPIO_write(gp3 = gp1 ^ gp2) # XOR gate
```

Este chip carece de resistencias internas de *pull-up* o *pull-down*. Por esta razón, cuando usamos pulsadores, debemos colocar una resistencia a positivo o a masa según el estado por defecto que queramos.


## Entradas analógicas (ADC)

Si las entradas digitales permitían leer valores 0 y 1, las entradas analógicas nos permite leer su tensión de forma continua. Sirven para potenciómetros, sensores de luz o temperatura, etc.

El MCP2221/A cuenta con un ADC de 10 bits. Es decir, registra valores entre **0** y **1023**. Siendo 0 el potencial de masa y **1024** la tensión de referencia (por defecto igual a la alimentación). Tenemos tres canales: **GP1**, **GP2** y **GP3**.

Al igual que ocurre con el resto de comandos, la tasa máxima de muestreo es 500Hz. Lo cual nos limita a usarlo sólo con señales que varían lentamente; a modo de tarjeta de adquisición de datos.

Como ejemplo, registraremos la tensión en los bornes de un **condensador** mientras este se carga o se descarga.

{% include image.html file="c_charge_sch_brd.png" caption="Esquema y montaje utilizado en el ejemplo de entradas analógicas. EyC." %}


**GP2** actúa aquí como salida lógica a la cual hemos conectado un condensador con una resistencia en serie. Cuando **GP2** está a nivel bajo, descarga el condensador. Y cuando la llevamos a nivel alto lo carga.

**GP3** será una **entrada analógica** con la que monitorizamos la tensión.

Esto es un extracto del código. El ejemplo completo lo tenéis en [GitHub V_T_plot_C.py](https://github.com/electronicayciencia/EasyMCP2221/blob/master/examples/V_T_plot_C.py).

```python
mcp.set_pin_function(
    gp2 = "GPIO_OUT",
    gp3 = "ADC")

mcp.ADC_config()
...

print("Charging...")
mcp.GPIO_write(gp2 = True)

while ... :

    Vc = mcp.ADC_read()[2]
```

Luego graficamos el resultado con PyPlot por ejemplo.

{% include image.html file="carga_c.png" caption="Tensión medida en el condensador durante la carga. EyC." %}

Como ya sabréis, el tiempo que tarda un condensador en alcanzar determinado nivel de carga viene dado por su capacidad y la resistencia en serie. Lo que llamamos **constante de tiempo RC**.

Con un condensador de **1uF** y una resistencia de **100k** la constante de tiempo (línea verde en el 63% aproximadamente) debería ser 100ms. Aquí está sobre los 90ms, eso es señal de alguno (o ambos) componentes tiene un valor inferior al nominal.


## Salida analógica

A diferencia de una salida digital, cuyos estados son 0 y 1, la salida de un DAC (*conversor de digital a analógico*) puede tomar varios valores. Hasta 32 valores distintos en este caso. Siendo 0 el valor de masa y **32** el valor de referencia (por defecto igual a la tensión de alimentación).

Tan sólo **GP2** o **GP3** pueden actuar como **salida analógica**. Aún así, el MCP2221/A cuenta con un único un DAC. Por lo que en la práctica sólo podemos utilizar GP2 o GP3. Ya que, si usamos las dos, ambas estarán al mismo valor. Con ellas, podemos generar una tensión precisa y controlada digitalmente. Servirá por ejemplo para generar una tensión de calibración, una forma de onda arbitraria, una señal de audio, etc.

Es muy sencillo generar una onda triangular:

```python
# Use GP2 as DAC output.
mcp.set_pin_function(gp2 = "DAC")

# Configure VDD as DAC reference
mcp.DAC_config(ref="VDD")

while True:
    for v in range(0,32):
        mcp.DAC_write(v)

    for v in range(30,0,-1):
        mcp.DAC_write(v)
```

{% include image.html file="dac_triangular.png" caption="Posibles tensiones de salida del DAC de 5 bits con referencia a la alimentación. EyC." %}

En el gráfico anterior se ve como cada valor se mantiene durante 2ms. Al igual que el resto de comandos del MCP2221/A, la tasa de actualización el DAC es 500Hz. En cuanto al valor de salida, el mínimo es 0 y el máximo es el 97% del valor de referencia.

Combinando el ADC y el DAC podríamos hacer un sencillo **trazador de curvas** digital. Y con él veamos la **caída de tensión** de un LED.

{% include image.html file="led_drop_sch_brd.png" caption="Esquema y montaje utilizado para mostrar la caída de tensión en un LED. EyC." %}

**GP2** la usaremos como salida analógica (DAC). Haremos subir su tensión de salida progresivamente.
Usando **GP1** como entrada analógica mediremos la tensión de salida real del DAC.
En **GP3** tendremos la tensión en el LED, como en el ejemplo del condensador.

```python
for step in range(0,32):
    mcp.DAC_write(step)

    (V1, _, V3) = mcp.ADC_read()

    # 10 bit, 5V ref
    Vr[step] = V1 / 1024 * 5
    Vd[step] = V3 / 1024 * 5
```

Este es un extracto de [GitHub - V_V_plot.py](https://github.com/electronicayciencia/EasyMCP2221/blob/master/examples/V_V_plot.py).

{% include image.html file="led_curve.png" caption="Caída de tensión en un LED en función del voltage de alimentación. EyC." %}

Sobre la **línea diagonal** están los puntos para los que la tensión en el LED es igual a la tensión aplicada. O, dicho de otra forma, la caída de tensión en la resistencia es cero porque **no hay** paso de corriente.

Hasta, aproximadamente, 1.4V no circula ninguna corriente por el diodo. Una vez llegado a este umbral, empieza a circular, y la caída de tensión se estabiliza sobre los 1.6V. Aumentando poco a poco a medida que aumenta la intensidad. Como en cualquier diodo.

Os podríais preguntar por qué es necesario monitorizar la tensión de salida real del DAC con **GP1** y no sirve con tomar el valor calculado.  Debemos medirla porque el DAC tiene una impedancia de salida muy elevada. Apenas es capaz de suministrar unos pocos miliamperios. Y, no sólo eso, la impedancia de salida no es fija, sino que depende de la tensión suministrada.

Veamos con un gráfico lo que queremos decir.

En este ejemplo vamos a comparar la tensión de salida real (medida en **GP1**) con la tensión de salida teórica de **GP2**.

{% include image.html file="dac_sch_brd.png" caption="Esquema utilizado para mostrar la impedancia interna del DAC." %}

El programa completo lo tenéis en [GitHub DAC_impedance_plot.py](https://github.com/electronicayciencia/EasyMCP2221/blob/master/examples/DAC_impedance_plot.py).

Este primer gráfico es sin carga. Quitaremos la resistencia. Sólo para ver que ambas tensiones, la real y la esperada coinciden dentro de un margen.

{% include image.html file="dac_noload.png" caption="Salida real del DAC frente a salida esperada, en ausencia de carga. EyC." %}

Veamos qué sucede a colocar una resistencia de 20kohm.

{% include image.html file="dac_20kload.png" caption="Salida real del DAC frente a salida esperada, con carga de 20kohm. EyC." %}

Ya veis cómo la recta se distorsiona de forma no lineal.

El DAC **no debe utilizarse** nunca para manejar cargas como un LED, un altavoz o un motor. Siempre debemos colocar un *buffer* a la salida como veremos más adelante.


## I2C

I2C es un protocolo de comunicación entre circuitos integrados muy sencillo y difundido. Para saber **cómo funciona I2C** os recomendamos leer [El bus I2C a bajo nivel]({{site.baseurl}}{% post_url 2017-02-25-el-bus-i2c-bajo-nivel %}).

Para darnos cuenta de su relevancia, es suficiente decir que nos permite comunicarnos con cientos de chips de todo tipo. Tales como ADC, DAC, memorias, sensores (de luz, de presión, de voltaje, de temperatura, de corriente, de distancia, de aceleración, de gas, de calidad del aire, ...), RTC, displays, procesadores criptográficos, controladores (de PWM, de 1-wire, de I/O...) entre otros.

El chip MCP2221/A es muy práctico para familiarizarnos con dispositivos I2C. No obstante, la **limitación** de los 2ms por comando tiene un fuerte impacto en su rendimiento.

Esto se debe a que cada transmisión suele requerir el envío de varios comandos consecutivos.

Pongamos por ejemplo leer un registro de un chip por I2C. Requeriría de estos **5 comandos**:

- antes de empezar, **obtener el estado** del módulo I2C para asegurarnos de que está libre
- **escribir en el bus** I2C la dirección del esclavo y del registro a leer
- de nuevo, **obtener el estado** del módulo I2C para saber si el esclavo atendió el comando
- **leer** un byte (o varios) del bus I2C y almacenarlo en el buffer interno del MCP2221
- **leer el buffer** interno para recuperar el/los bytes leídos

Eso son 10 ms. Independientemente de la velocidad del bus y del número de bytes.

Por esta razón, siempre resultará **más conveniente** leer o escribir **varios bytes seguidos** si es posible y no hacerlo de uno en uno.


## I2C raw

Veamos ahora algunos ejemplos.

Empecemos por un módulo con el chip PFC8591 - [datasheet PFC8591](https://www.nxp.com/docs/en/data-sheet/PCF8591.pdf). El mismo que ya utilizamos en [Conexión GPIO de Raspberry Pi 3]({{site.baseurl}}{% post_url 2016-11-20-conexion-gpio-de-raspberry-pi-3 %}).

Se trata de un ADC muy sencillo y muy fácil de usar. Tiene una resolución de 8 bits y cuatro canales. Venden módulos con el chip, una resistencia sensible a la luz (LDR), otra sensible a la temperatura (NTC), un potenciómetro y una cuarta entrada flotante.

Conectaremos este módulo a nuestro MCP2221/A siguiendo el esquema de la imagen:

{% include image.html file="pcf_sch_brd.png" caption="Esquema y montaje utilizados para probar un módulo PFC8591. EyC." %}

Lo primero es saber si el dispositivo está **bien conectado** y responde.

Cada dispositivo I2C tiene una *dirección* que va entre 0 y 127. Un **escáner I2C** consiste en probar a leer un byte de cada dirección posible. Si hay algún chip conectado responderá y anotaremos que en esa dirección hay algo escuchando.

```python
for addr in range(0, 0x80):
    try:
        mcp.I2C_read(addr)
        print("I2C slave found at address 0x%02X" % (addr))

    except EasyMCP2221.exceptions.NotAckError:
        pass
```

El código completo lo tenéis en [GitHub - I2C_scan.py](https://github.com/electronicayciencia/EasyMCP2221/blob/master/examples/I2C_scan.py).

El PCF8591 atiende en la dirección 0x48.

```console
$ python I2C_scan.py
Searching...
I2C slave found at address 0x48
```

Una vez sabemos que responde, queda la parte más difícil: comunicarnos con él.

Pero cada chip tiene unos comandos y una interfaz particulares. Por suerte el PFC8591 es muy sencillo de utilizar. Tan sólo debemos escribir el byte de control para que incremente automáticamente el canal y después leer 4 bytes seguidos (uno por cada canal).


```python
# Control register:    .0.. .... - No DAC output
#                      ..00 .... - 4 individual inputs
#                      .... .1.. - Auto-increment channel
#                      .... ..01 - ADC start channel 1
mcp.I2C_write(addr, [0b0000_0101])

while True:
    (ntc, ldr, flo, pot) = mcp.I2C_read(addr, 4)
    print("NTC: %2d%%,  LDR: %2d%%,  Float: %2d%%,  Pot: %2d%%" %
        (ntc / 256 * 100,
         ldr / 256 * 100,
         flo / 256 * 100,
         pot / 256 * 100))
```

El ejemplo completo lo tenéis en [GitHub PCF8591.py](https://github.com/electronicayciencia/EasyMCP2221/blob/master/examples/PCF8591.py).

El resultado es algo así:

```
NTC: 45%,  LDR: 54%,  Float: 42%,  Pot: 10%
NTC: 45%,  LDR: 56%,  Float: 44%,  Pot: 10%
NTC: 45%,  LDR: 53%,  Float: 42%,  Pot: 10%
NTC: 45%,  LDR: 50%,  Float: 37%,  Pot: 10%
NTC: 45%,  LDR: 49%,  Float: 35%,  Pot: 10%
NTC: 45%,  LDR: 49%,  Float: 39%,  Pot: 10%
```

## I2C Slave Helper

Otros dispositivos I2C operan con **registros**. Cada chip tiene unos registros que admiten unos valores (escritura) o contienen ciertos datos (lectura).

Se trata la clase **I2C Slave Helper** es una librería en el módulo EasyMCP2221 que nos facilita esta operación.

Tomaremos como ejemplo un sensor I2C que trabaja con registros. El [AMG8833 8x8 IR Grid Eye](https://cdn.sparkfun.com/assets/4/1/c/0/1/Grid-EYE_Datasheet.pdf) es un sensor infrarrojo que contiene en su interior 64 sensores en una matriz de 8x8. Con él podría hacerse una **termocámara** aunque con una resolución de sólo 64 pixeles. Está ajustado para detectar la temperatura corporal. Por lo que se podía utilizar para identificar personas con **fiebre** durante el COVID, o como detector de movimiento o **presencia**.

Aunque este sensor sólo funciona a 3.3V, el módulo que estamos usando integra un regulador de tensión modelo [XC6206](https://product.torexsemi.com/system/files/series/xc6206.pdf). Lo cual nos permite alimentarlo a **5V** sin ningún problema.

{% include image.html file="amg_sch_brd.png" caption="Esquema y montaje utilizados para probar un sensor AMG8833. EyC." %}

Cada uno de los 64 sensores devuelve un valor de 2 bytes. Así pues, para obtener la imagen térmica debemos leer 128 bytes desde el registro `80h` en adelante. [AMG88** reference - Panasonic](https://cdn-learn.adafruit.com/assets/assets/000/043/261/original/Grid-EYE_SPECIFICATIONS%28Reference%29.pdf?1498680225).

```python
mcp.I2C_speed(400_000)
sensor = mcp.I2C_Slave(0x69)

while True:
    data = sensor.read_register(0x80, 128)
```

El ejemplo completo está en [GitHub - AMG8833.py](https://github.com/electronicayciencia/EasyMCP2221/blob/master/examples/AMG8833.py). Incluyendo la lectura de los datos, la conversión de *11 bits + signo* a float y la representación como mapa de calor.

{% include image.html file="amg_ir_picture.png" caption="Un *selfie* en el infrarrojo. EyC." %}


La clase I2C Slave Helper también nos servirá para interactuar con una memoria **EEPROM** del tipo 24LC.

Si bien no se organizan en **registros**, podemos tratarlas como tal. Siempre que, al inicializar la clase *I2C_Slave*, indiquemos que las direcciones de los registros serán de dos bytes, en vez de uno sólo como es habitual.

{% include image.html file="eeprom_sch_brd.png" caption="Esquema y montaje utilizados para probar una EEPROM. EyC." %}

Así escribimos una cadena de bytes en una dirección cualquiera. Y seguidamente la recuperamos de la memoria.

```python
>>> import EasyMCP2221
>>> mcp = EasyMCP2221.Device()
>>> eeprom = mcp.I2C_Slave(0x50, reg_bytes=2)

>>> eeprom.write_register(0x3FC0, b'Hola. Probando.')

>>> eeprom.read_register(0x3FC0, 15)
b'Hola. Probando.'
```

En realidad la 24LC128 no tiene 16000 registros, sino 256 **páginas** de 64 bytes cada una.

En binario necesitamos 8 bits para indicar la página (256) y 6 bits más para decir la posición dentro de la página (64).

Podemos escribir la dirección `3FC0` en binario `00_11111111_000000`. Así separado vemos claramente como estamos haciendo referencia al  *comienzo de la última página*.

```python
>>> eeprom.write_register(0b00_11111111_000000, 64 * b'A')
>>> eeprom.read_register(0b00_11111111_000000, 64)
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
```


## SMBus

En un artículo anterior llamado [La presión atmosférica, BMP280]({{site.baseurl}}{% post_url 2018-10-07-la-presion-atmosferica-bmp280 %}) describimos el **BMP280**. Un sensor de **temperatura** y **presión** barométrica.

Si recordáis, era complicado de usar. Para leer la temperatura o la presión debíamos leer **múltiples registros** y combinarlos mediante una serie de **operaciones aritméticas**.

Por suerte, existen librerías *Open Source* listas para interactuar con los chips más comunes. Lo normal es que dichas librerías utilicen el protocolo **SMBus**, semejante al I2C.

Un PC corriente no cuenta con SMBus externo, por lo que sólo podríamos ejecutarlas en una Raspberry o similar. Pero [Easy MCP2221 / SMBus](https://easymcp2221.readthedocs.io/en/latest/smbus.html#) proporciona una clase **compatible con SMBus**. La cual nos permitirá utilizarlas localmente **en nuestra máquina**.

Por ejemplo, tomemos el **BME280**. Un triple sensor combinado de **temperatura**, **humedad** y **presión** barométrica. Para manejar este chip existe una librería llamada `pimoroni-bme280`.

La librería BME280 utiliza la interfaz SMBus. El módulo EasyMCP2221 traducirá las órdenes a comandos MCP2221/A. Este mecanismo sirve igual tanto en **Windows** como en **Linux**.

Con estas líneas haríamos una sencilla estación meteorológica.

```python
from EasyMCP2221 import SMBus
from bme280 import BME280

bus = SMBus(1)
bme280 = BME280(i2c_dev=bus)

temperature = bme280.get_temperature()
pressure    = bme280.get_pressure()
humidity    = bme280.get_humidity()

print('{:05.2f}*C {:05.2f}hPa {:05.2f}%'.format(temperature, pressure, humidity))
```

Resultado:

```
17.93*C  983.76hPa  51.57%
```


## Interfaz universal por USB

Hemos decidido proyectar una **Interfaz universal USB** con estas características principales:

- Capaz de alimentar circuitos externos a 3.3V y 5V hasta 300mA.
- Protección contra cortocircuitos en I/O y alimentación
- Puerto I2C
- Puerto serie UART
- Sonda lógica de cuatro canales
- Salida DAC filtrada y amplificada

{% include image.html file="mcp2221-board-v1.svg" caption="Esquema de la interfaz universal con MCP2221/A. Imagen vectorial ampliable. EyC." %}

Dividiremos en partes el esquema para explicarlo mejor.

{% include image.html file="interf_power_input.png" caption="Sección de alimentación. EyC." %}

Una de las funciones de la placa será servir como alimentador de circuitos externos a 5 y 3.3V. Además debe estar protegida contra cortocircuitos.

Inmediatamente tras la entrada de alimentación nos encontramos **F1**. Se trata de un fusible **autorrearmable** de la [serie 1206L de Littelfuse](https://www.littelfuse.com/products/polyswitch-resettable-pptcs/surface-mount/1206l).

Este tipo de fusibles funcionan como una resistencia **PTC**. Es decir se calientan al paso de la corriente eléctrica. Al calentarse, su resistencia interna aumenta. Lo cual provoca que se calienten más aún, en un proceso realimentado, restringiendo la intensidad lo suficiente como para no causar daños al circuito.

Este modelo soporta una **corriente mantenida** (*I<sub>hold</sub>*) de 250mA. Significa que, con una temperatura ambiente de 25ºC, nunca se desconectará si estamos por debajo de 250mA.

Su **intensidad de disparo** (*I<sub>trip</sub>*) es de 500mA. Lo que significa que, llegados a esta intensidad, comenzará el proceso que acabamos de describir. Empezará a calentarse hasta saltar. Más rápido cuanto más elevada es la corriente.

{% include image.html file="fuse.png" caption="Comportamiento en cortocircuito del fusible autorrearmable 1206L025 con 5V. EyC." %}

En paralelo con **F1** encontramos el led amarillo **D1** y su resistencia en serie. Este LED sólo lucirá cuando **F1** esté abierto, indicando así la condición de cortocircuito.

**C1** atenuará las caídas de tensión puntuales ocasionadas por la resistencia conjunta del cable de alimentación y de **F1**. Según el estándar USB, este condensador no debe superar los 10uF. De no ser así, el consumo súbito al conectar el circuito incumpliría la especificación. En consecuencia, algún controlador podría desactivar el bus al considerar el dispositivo como defectuoso.

**U1** es un regulador de 3.3V tipo MCP1702 de Microchip. Capaz de entregar 250mA sostenidos y hasta 550mA en picos. Esta configuración ya la vimos en la entrada [Proyectos a batería y cerveza fría]({{site.baseurl}}{% post_url 2021-10-24-bateria-cerveza-fria %}). **C2** es necesario para evitar auto-oscilaciones. Y **C3** sirve para estabilizar la tensión de salida durante los picos de corriente mientras **U1** se adapta y reacciona al cambio.

El conmutador **v_select** nos permite seleccionar si trabajaremos con los 5V directamente desde el USB o con los 3.3V del regulador.

La línea que hemos nombrado como **VDD** alimentará el integrado **U4**, los buffer de salida y los conectores. Pero, atención, porque las sondas lógicas se alimentarán siempre a 5V.

{% include image.html file="interf_buses.png" caption="Sección de salida UART e I2C. EyC." %}

Las señales de I2C y UART vienen directamente del MCP2221/A **U4**.

En el caso del bus I2C hemos colocado las resistencias **R6** y **R7** como pull-up a la línea de VDD, que puede ser 5 o 3.3V. El valor de estas resistencias no es crítico. Pudiendo ser cualquiera entre 1k y 10k. Aunque una resistencia mayor alto podría dificultar las transmisiones I2C a alta velocidad (400kHz) si el bus supera una cierta longitud.

{% include image.html file="interf_logic.png" caption="Detalle de la sonda lógica. EyC." %}

A cada salida conectamos una sonda lógica muy simple. Se compone de un amplificador operacional tipo **LM358** actuando como comparador y un par de LEDs.

**U2A** compara la señal de la entrada inversora con la señal de referencia que viene de **RV1**. Si la tensión en la entrada **inversora** se mantiene por debajo de la tensión de referencia, la salida de **U2A** estará en nivel alto. En estas condiciones sólo estará encendido el LED **verde**, **D6**. Señalizando *nivel bajo*.

Cuando la tensión en la patilla inversora aumente, bien porque se ha activado una patilla de **U4** (si actúa como salida) o bien porque hemos suministrado una tensión externa (en caso de actuar como entrada), la salida de **U2A** se irá a nivel bajo. Activando el LED **rojo**, **D2** y apagando el LED verde.

Con **RV1** ajustaremos la tensión de referencia para igualarla con la que el MCP2221/A detecta como nivel alto (alrededor de 1.2V).

Esta es la única parte del circuito que se alimenta siempre a **5V**. De esta forma no alteraremos la tensión de referencia ni el brillo de los LED al cambiar el voltaje de salida.

{% include image.html file="interf_io.png" caption="Detalle de una entrada/salida. EyC." %}

Los conectores de entrada/salida, tienen una doble función.

El pin **2** de **J5** está pensado para ser usado como **entrada o salida**.

La resistencia **R15** limita la corriente a unos 20mA en caso de consumo excesivo o **cortocircuito**. Lo cual puede ocurrir muy fácilmente si **por error** pensamos que tenemos configurada una patilla de **U4** como **entrada** lógica, pero en realidad la habíamos configurado como **salida**.

En el pin **3** hemos colocado un buffer y, por tanto, sólo puede usarse como **salida**.

Para el buffer hemos seleccionado un operacional modelo **MCP6024** o MCP6004 también de **Microchip**. Este operacional cuenta con entrada y salida **rail-to-rail**. Dicho de otra forma, tanto la entrada como la salida pueden abarcar desde cero hasta el positivo de alimentación. Cosa que por ejemplo el **LM358** no puede hacer. Esta característica es imprescindible en el caso de las salidas **GP2** y **GP3** ya que el DAC puede abarcar todo este rango.

**R12** y **C5** forman un filtro pasa bajos con el que filtraremos el ruido del DAC.

Las salidas de **U5** están protegidas contra sobre corrientes.

Para las patillas GP0 y GP1 no es estrictamente necesario un buffer *rail-to-rail* pero aún así, el LM358 se quedaría corto cuando trabajáramos a 3.3V.

Tanto el terminal **4** de **J5** como **U5** están conectados a la línea **VDD**, pudiendo seleccionar su tensión de salida.


## EasyMCP Workbench

Para que trabajar con este chip sea aún más sencillo, tenemos una aplicación gráfica basada en la librería EasyMCP2221.

Es muy práctica para hacer un escáner I2C rápido, medir tensiones con el ADC o fijar una tensión en el DAC para alguna prueba. También para comprobar la configuración del chip y cambiarla si es conveniente.

Permite configurar la función de cada patilla, leer los ADC en tiempo real, variar el DAC, detectar dispositivos I2C... Además de otras funciones de las que **no hemos hablado** en este artículo, como visualizar la actividad I2C o UART, configurar la salida de reloj, la Interrupción al Cambio (IOC) o la gestión de energía del USB con *remote wake-up*.

La podéis descargar de [GitHub - EasyMCP2221 Workbench GUI](https://github.com/electronicayciencia/EasyMCP2221-GUI).

{% include image.html file="workbench.png" caption="EasyMCP2221 Workbench. Aplicación en tiempo real basada en EasyMCP2221. EyC." %}


## Proyecto avanzado: RTC

Hasta ahora hemos tratado proyectos sencillos. El MCP2221/A, sin embargo, tan sólo pone a nuestra disposición el *hardware*. El proyecto puede ser tan complejo como imaginemos (dentro de las limitaciones del integrado).

Vamos a ver **dos proyectos** un poco más avanzados.

El primero es aprender el **cómo funciona un RTC** (*Real Time Clock*).

Un RTC es un chip que sirve como reloj y calendario externo. Actúa de apoyo al microcontrolador principal; ya que utiliza un cristal de cuarzo para mantener su propia frecuencia y puede funcionar en ausencia de la alimentación, con una batería de respaldo.

El RTC que utilizaremos es un clásico [**DS1307**](https://www.analog.com/media/en/technical-documentation/data-sheets/DS1307.pdf) con interfaz I2C.

{% include image.html file="proy_rtc_sch.png" caption="Esquema del proyecto RTC. EyC." %}

Hemos conectado al bus **I2C** dos elementos: el **RTC** y una pantalla **LCD** donde escribiremos la fecha y la hora.

El uso que haremos de las patillas GPIO del **MCP2221/A** es el siguiente:

**GP0** está en modo **salida digital**. Desde ella alimentamos el DS1307. Cuando esté a nivel **alto** el integrado funcionará normalmente. Y llevándola a nivel bajo simulamos un *corte de alimentación*.

**GP1** está en modo **IOC** (detección de cambios). El RTC puede configurarse para sacar por la patilla 7 una señal de 1Hz. Cada segundo, su flanco de bajada **disparará** el proceso que lee la fecha y hora y la escribe en la pantalla LCD.

**GP2** actúa en modo **DAC** y simula la alimentación de respaldo, la batería. Jugando con el valor de salida simulamos una batería cargada o descargada.

**GP3** está en modo indicador de **actividad I2C**. El LED se encenderá sólo cuando el bus I2C esté activo. Bien sea leyendo la fecha o escribiendo en la LCD.

El código lo tenéis en [GitHub - I2C Clock](https://github.com/electronicayciencia/EasyMCP2221/tree/master/examples/clock)

{% include image.html file="proy_rtc_brd.jpg" caption="Montaje del proyecto RTC utilizando la Interfaz Universal proyectada anteriormente. EyC." %}


## Práctica con LEDs

Para terminar, veamos otro proyecto.

Utilizaremos una placa basada el en chip [PCA9685](https://www.nxp.com/products/power-management/lighting-driver-and-controller-ics/led-controllers/16-channel-12-bit-pwm-fm-plus-ic-bus-led-controller:PCA9685). Un controlador PWM de 16 canales con interfaz I2C. La podéis encontrar como controlador para servos, aunque el chip en un principio es para LEDs.

Usaremos la interfaz I2C para comandar el PCA9685 y hacer varios **efectos** en una serie de LEDs.

{% include image.html file="proy_kitt_sch.png" caption="Esquema del proyecto de efectos luminosos. EyC." %}

La patilla **GP0** estará configurada como **entrada digital**. La conectaremos a un pulsador a masa con una resistencia de *pull-up*. Puede servirnos para cambiar de efecto o para encender y apagar.

Las patillas **GP1**, **GP2** y **GP3** las configuraremos como **entrada analógica** y las conectaremos a tres potenciómetros. Servirán para controlar distintos parámetros.

Tenéis el código en [GitHub - I2C ledbar](https://github.com/electronicayciencia/EasyMCP2221/tree/master/examples/ledbar).

{% include image.html file="proy_kitt_brd.jpg" caption="Montaje del proyecto efectos luminosos utilizando la Interfaz Universal. EyC." %}

Este sería el resultado

{% include video.html class="medium-width" file="led_kitt.mp4" caption="Efecto *coche fantástico*. Simulación con LEDs de la inercia térmica en bombillas incandescentes. EyC." %}


## Conclusión

El MCP2221/A es un chip muy interesante que puede servirnos en múltiples proyectos. Bien sea aprender a utilizar algún sensor. Bien para introducir a un estudiante en el mundo de la robótica y programación. O bien como pequeño laboratorio de prácticas.

Carece de la autonomía de un microcontrolador, sí, puesto que siempre debe estar conectado a un ordenador que ejecuta el software. Pero a cambio nos da la simplicidad de no tener que programarlo y la facilidad de depurar el código en cualquier IDE.

No es el único integrado que puede hacer de puente entre USB e I2C, pero si el único que tiene entradas y salidas **analógicas** no requiere componentes externos y además se presenta en **formato DIP**.


